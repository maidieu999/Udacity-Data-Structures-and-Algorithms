## Problem 1

Solution Logic:
Use python ordered dictionary which works as map data structure
to keep the (key, value) pair in the cache.

When setting value to the cache. If the key already exists in the cache, move that key to the lastest position in the cache.
If the max cache size is reached, remove the oldest key, then set the last key value

When getting value in the cache. If the key already exists in the cache, move that key to the lastest position in the cache then return this value.
If the key does not exists in the cache, return -1

Solution Time Complexity - O(1):
Set, get, pop and popitem operations in python ordered dictionary takes constant time
Set: O(1)
Get: O(1)
Pop: O(1)
Popitem: O(1)

## Problem 2

Solution Logic:
List the files in the present directory.
If an entry is a file and ends with the given suffix, add this file path to the result list
If an entry is directory, call the function recursively to check file and directories inside this directory

Solution Time Complexity:
n = total number of files/directories in the given path.

List Directory Contents: O(n)
Checking if Entry is a File or Directory: O(1)
Recursion: If there are m files in the entire file system tree and the depth of the directory structure is d, the time complexity can be expressed as O(m * d), considering the iteration over files and the depth of recursion
=> Overall, Recursion is the most costly operation - O(m * d)

## Problem 3

The main logic involves building a Huffman tree from the given text, where each character is represented by a leaf node and the frequencies of characters determine the structure of the tree. Then, the Huffman codes for each character are generated by traversing the tree, with '0' representing a left child and '1' representing a right child. Finally, the text is encoded using these Huffman codes, and the encoded data is decoded back to the original text using the Huffman dictionary.

Solution Time Complexity - O(m * d):
Building the frequency table - collections.Counter: O(n)
Building the Huffman tree: The construction of the Huffman tree involves repeatedly selecting and combining nodes based on their frequencies. This process is performed until a single root node is obtained. Since at each iteration, the number of nodes decreases by one, and the process involves sorting the nodes based on their frequencies, the time complexity of building the Huffman tree is O(n log n), where n is the number of unique characters in the input text.
Generating Huffman codes: The construction of the Generating Huffman codes involves traversing the tree. The time complexity of generating Huffman codes is O(n), where n is the number of unique characters in the input text.
Encoding and decoding: The time complexity of encoding and decoding depends on the length of the input text and the length of the Huffman codes. Since encoding and decoding involve iterating over the input text and performing lookups in the Huffman code dictionary, the time complexity is O(m), where m is the length of the input text.
=> Overall, the time complexity is dominated by the construction of the Huffman tree - O(n log n)

## Problem 4

If the user is not found in the current group, the function recursively traverses each subgroup to check for the user. The recursion continues until the user is found or until there are no more subgroups to explore.
At each level of recursion, the function explores all subgroups.

Solution Time Complexity - O(m * n)
O(n * m) in the worst case, where n is the number of user accounts and m is the number of subgroups in the group tree

## Problem 5

The provided code implements a basic blockchain structure using Python classes, consisting of blocks linked together in a chain. Each block contains data, a timestamp, and a hash value calculated based on its contents and the hash of the previous block. The blockchain class manages the chain by appending new blocks, calculating hashes, and providing a string representation of the blockchain for visualization.

Solution time complexity - O(n)
Appending a block: O(1)
Getting the previous hash: O(1)
Generating the string representation: O(n)

## Problem 6

This solution using a linked list data structure (Node and LinkedList classes) and provides functions to compute the union and intersection of two linked lists. For union, unique values from both lists are collected into a set, and then added to a new linked list, ensuring no duplicates. For intersection, common values between both lists are identified, and only those are added to a new linked List

Solution time complexity - O(m + n)
The time complexity for the union and intersection operations is O(n + m), where n and m are the sizes of the input linked lists, respectively, as both operations involve traversing the linked lists once to collect or identify values.